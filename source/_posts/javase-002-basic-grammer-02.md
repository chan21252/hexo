---
title: JAVASE学习笔记—002 Java语法基础—（2）基本数据类型
date: 2019-05-01 21:41:36
tags:
- java
- javase
category:
- java
---

## 一、Java的数据类型

1. 基本数据类型（8种）
    1. byte
    2. short
    3. int
    4. long
    5. float
    6. double
    7. char
    8. boolean
2. 引用数据类型
    1. 数组
    2. String
    3. 自定义类型

<!-- more -->

## 二、整型

整型：存储带符号整数。Java中有四种整型类型，存储范围从小到大：byte<short<int<long。

### byte
- 类型关键字 byte
- 内存存储长度为1个字节（1个字节占8位）
- 存储数据范围 -128 ~ 127（-2^7 ~ 2^7-1）

### short
- 类型关键字 short
- 内存存储长度为2个字节（1个字节占8位）
- 存储数据范围（-2^15 ~ 2^15-1）

### int
- 类型关键字 int
- 内存存储长度为4个字节（1个字节占8位）
- 存储数据范围（-2^31 ~ 2^31-1）

### long
- 类型关键字 long
- 内存存储长度为8个字节（1个字节占8位）
- 存储数据范围（-2^63 ~ 2^63-1）

**tips**:
jvm默认将整数常量当作int类型来处理。long类型变量接受一个超出int范围的常数，需要在数据末尾加上字母“L”或“l”。

``` java
public class LongDataType {
    public static void main(String[] args) {
        long lon = 5555;
        System.out.println("lon 的值是 " + lon);

        /* 以下代码会发生什么 */
        //lon = 3025164895;   //错误，jvm默认会把整数当作int类型来处理，3025164895超出int范围
        lon = 3025164895L;
        System.out.println("lon 重新赋值后是 " + lon);
    }
```

### 获取数据类型允许的最小和最大值
- Byte.MIN_VALUE
- Byte.MAX_VALUE
- Short.MIN_VALUE
- Short.MAX_VALUE
- Integer.MIN_VALUE
- Integer.MAX_VALUE

### 获取整型的二进制字符串

Integer.toBinaryString(int i);
Long.toBinaryString(long l)

## 三、浮点型

浮点型是用来存储分数（小数）的数据类型，Java中包含2种浮点类型，存储范围从小到大：float<double。

### float
- 类型关键字 float
- 内存存储长度为4个字节（1个字节占8位）
- 存储数据范围（1.4E-45 ~ 3.4028235E38）
- 获取最大和最小值：
    - Float.MAX_VALUE;
    - Float.MIN_VALUE;

**tips**:
1. jvm默认将小数常量当作double类型来处理。float类型变量接受小数，需要在数据末尾加上字母“F”或“f”。
2. 将整型数据赋值给float类型变量，jvm会为float自动加上小数位，因为float精度比整型高。

### double
- 类型关键字 double
- 内存存储长度为8个字节（1个字节占8位）
- 存储数据范围（4.9E-324 ~ 1.7976931348623157E308）
- 获取最大和最小值：
    - Double.MAX_VALUE;
    - Double.MIN_VALUE;

**强烈建议使用double类型存储分数（小数）**

### 科学计数法

2E5 表示 2乘以10的五次方。
科学计数法只能用来表示浮点类型数据。

## 四、字符类型

Java中使用**char**数据类型存储单个字符。jvm对字符采用Unicode无符号进行编码，char可以存储0-65535的非负数。

字符常量：'A', '9', '$', '\\t', '\\n', '\\\\'

- 类型关键字：char
- 内存存储长度为2个字节（1个字节占8位）
- 存储数据范围（0 ~ 2^16-1）

转义字符：
单引号：\\'
双引号：\\"
换行符：\\n
制表符：\\t

### char和int类型兼容使用

1. char 可以接受int类型数字，但是不能int数字不能超过char的范围。保存的是int类型数字对应的字符。char的范围比int小，可能会丢失精度，所以需要强制类型转换。
2. int 可以接受char类型数据，保存的是char字符对应的数字。
3. 输出char字符对应数字，强制类型转换为int类型，(int)char
4. 输出int数字对应的char字符，强制类型转换为char类型，(char)int


## 五、布尔类型

Java中是否使用boolean数据类型表示是与否，真与假的数据存储。boolean是逻辑判断的数据类型。

boolean类型数据的计算结果只能是true和false。

boolean bool = true; bool = false;

标准的jvm规范定义Java语言在计算机底层使用int类型存储boolean类型数据，所以boolean类型占有4个字节存储空间，由于jvm的实现不同，boolean类型的底层存储也有可能不同。


## 六、数据类型的转换

1. 自然转换：由低精度向高精度数据类型转换
2. 强制转换：由高精度向低精度数据类型转换

由小到大自然转换，byte<short<int<long<float<double

强制类型转换语法：
低精度变量 = (低精度类型关键字)高精度数据;
int num = (int)60.5;

### **强制类型转换，数据溢出的问题**：

``` java
int num2 = 129;
byte by2 = (byte)num2;
System.out.println(by2);    //输出-127
```

**思考：byte的最大值是128，将int类型的129强制转换赋值给byte变量，为何会输出-127？**

### 预备知识（原码、反码、补码）：

#### 机器数和真值
机器数：
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
那么，这里的 00000011 和 10000011 就是机器数。

真值：
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

#### 原码

> 原码是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。

#### 反码

> 正数的反码还是等于原码。
> 负数的反码就是他的原码除符号位外，按位取反。

#### 补码

> 正数的补码等于他的原码
> 负数的补码等于反码+1。（这只是一种算补码的方式，多数书对于补码就是这句话）

在《计算机组成原理中》，补码的另外一种算法是
> 负数的补码等于他的原码自低位向高位，尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。

#### 同余

> 两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余。

例如，当m=12时，3跟15是同余的，因为3mod12=3=15mod12。

对于同余，有如下结论：
1. a，b是关于m同余的，当且仅当，二者相差m的整数倍， 
    a−b=k·m,with k=……−2,−1,0,1,2,……a−b=k·m,with k=……−2,−1,0,1,2,…… 
    即， 
    a=b+k·m,with k=……−2,−1,0,1,2,……a=b+k·m,with k=……−2,−1,0,1,2,……
2. 一个数x加a对m取余，等于x加a的同余b对m取余，即， 
    (x+a) mod m = (x+b) mod m
    由1.易知2.是成立的。

#### 补码的思想

我们知道计算机只有加法器，没有减法器，那么就需要将加法变成加法。怎么变？ 
经过上面的介绍，我们知道，在对m取余的情况下，加上一个数，相当于加上这个数的同余，即， 
若b = a + km，则(x+a) mod m = (x+b) mod m。

>举个例子: 
以时钟的时针为例，因为，10 = -2 + 12。 
当前时刻t=3，向后拨2个小时得，(t−2) mod 12 = 1 mod 12 = 1;
也就相当于向前拨10个小时，(t+10) mod 12 = 13 mod 12 = 1。
结论：通过同余，减法操作变成了加法操作。

>定义m为除去符号位后，能表示的数字的个数。 
例如，用8位表示整数，除去符号位，还剩7位，能表示的数字的就是000 0000~111 1111，共128个数字。所以此时m=128。

**负数的补码和原码之和等于m，因此求同余的过程就是求补码。**

负数的补码等于原码的符号位不变，其它位取反，再加1。 那么不看不符号位，将负数的补码和原码相加等于多少呢？全1再加1，就等于m！

#### 用同余进行计算

我们以3-2为例计算。

8位去除符号位后的m等于128，128 - 2 = 126，即126 = -2 + 128
根据同余定理，(3 - 2) mod 128 = (3 + 126) mod 128

在模为m的时候，x减去一个数，和x加上该数的补码值，这样减法就变成了加法
0000 0011 --3的原码补码反码都一样
1111 1110 --126的原码，-2的补码
\+
\_\_\_\_\_\_\_\_
0000 0001 -- 1（符号位也参与运算）

byte的最大值是128，将int类型的129强制转换赋值给byte变量，为何会输出-127？

计算机中存储的是补码
00000000 00000000 00000000 10000001 --int类型129二进制补码
                           10000001 --强制转为byte类型，只保留最末8位，其他丢弃
                           11111111 --原码=-127

参考文章:
[“补码”的数学原理](https://blog.csdn.net/wu_nan_nan/article/details/54633506)
[原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)